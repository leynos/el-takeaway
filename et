#!/usr/bin/env bash
#
# Copyright Â© 2014, David McIntosh <dmcintosh@df12.net>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided this permission
# notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

typeset -i ID_DIGITS=12
typeset -i SUCCESS=0
typeset -i FAIL=1

shopt -s extglob

# Return success if the given value is a valid Ello id (padded or unpadded)
#   is_id candidate
function is_id
{
    cand=$1
    exp="^0*[0-9]{1,${ID_DIGITS}}$"
    [[ "${cand}" =~ ${exp} ]]
}

# Returns success if the current directory is an initialized VCS repository
function has_repo
{
    if [[ -d './.hg' ]]; then
        echo 'hg'
        return ${SUCCESS}
    elif [[ -d './.git' ]]; then
        echo 'git'
        return ${SUCCESS}
    fi
    return ${FAIL}
}

# Returns success if the current directory has uncommitted version control
# changes
#   has_uncommitted_changes hg | git
function has_uncommitted_changes
{
    repo_type=$1
    if [[ "${repo_type}" == 'hg' ]]; then
        count=$(hg status | wc -l)
    elif [[ "${repo_type}" == 'git' ]]; then
        count=$(git status -s | wc -l)
    fi
    (( count ))
    return
}

# A simple confirmation notice, requiring the user to type 'yes' in upper or
# lower case if -e is specified, a non-confirming response will exit
#   confirm [-e] message
function confirm
{
    typeset -l input
    if [[ $1 == '-e' ]]; then
        do_exit=1
        shift
    else
        do_exit=0
    fi
    echo $*
    read input
    while [[ $input != 'yes' ]]; do
        if (( do_exit )); then
            exit ${SUCCESS}
        fi
        read input
    done
}

# Retreieve a key value pair from a conf file
#   get_conf filename key
function get_conf
{
    conf_file=$1
    key=$2

    if [[ ! -f "${conf_file}" ]]; then
        return ${FAIL}
    fi

    pair=$(grep -E "^${key}\\s*=" "${conf_file}")
    if (( $? != ${SUCCESS} )); then
        return ${FAIL}
    fi
    value=${pair#*=}
    echo "${value## }"
    return ${SUCCESS}
}

# Write a key value pair to a conf file
#   write_conf filename key value
function write_conf
{
    conf_file=$1
    key=$2
    value=$3
    temp_conf_file=$1.$$

    if [[ -f "${conf_file}" ]]; then
        grep -v -E "^${key}\\s*=" "${conf_file}" > "${temp_conf_file}"
    fi
    echo "${key} = ${value}" >> "${temp_conf_file}"
    mv "${temp_conf_file}" "${conf_file}"
    return ${SUCCESS}
}

# Print the file corresponding to the given post id to the stdout
#   get_filename id
function get_filename
{
    id=$1

    patt="%0${ID_DIGITS}d"
    for file in post-$(printf "${patt}" "${id}")*(-+([0-9A-Za-z_])).md
    do
        [[ -f "${file}" ]] || continue
        echo "${file}"
        return ${SUCCESS}
    done
    return ${FAIL}
}

# Format an individual post by removing leading and trailing quotes and
# replacing <br> and \n with newlines.  The formatted file will be written to
# stdout
#   format_post filename
function format_post
{
    awk '\
/^["]/  { 
    innerstr = substr($0, 2, length($0) - 2); 
    gsub("<br>", "\n", innerstr);
    gsub(/\\n/, "\n", innerstr);
    gsub(/\\["]/, "\"", innerstr);
    print innerstr
}
/^[^"]/ { print $0; }' < $1
}

# Write a post to disc, naming it for the Ello API post id
# The post should be provided via stdin
function write_post
{
    typeset filename=''
    first=1
    filename=$(jq '.id,.created_at,.body[].data' | while IFS='' read -r line
        do
            if (( first )); then
                id=${line}
                filename=$(get_filename ${id})
                if (( $? )); then
                    # if no existing file, select new filename
                    patt="%0${ID_DIGITS}d"
                    filename="post-$(printf "${patt}" "${id}").md"
                fi
                exec 8> "${filename}"
                first=0
                # echo "Parsing post ${id}" >&2
                echo "${filename}"
            else
                echo "$line" >&8
            fi
        done)
    err=${PIPESTATUS[0]}
    exec 8>&-
    if (( err )); then
        return $err
    fi
    tmp=${filename}.$$
    format_post "${filename}" > "${tmp}"
    mv "${tmp}" "${filename}"
}

# Perform an action on each post in an Ello JSON dump
# The JSON dump should be provided via stdin
#   each_post action
function each_post
{
    while IFS='' read -r line
    do
        if [[ "${line:0:1}" == "{" ]]; then
            post=${line}
        else
            post=${post}${line}
        fi
        if [[ "${line:0:1}" == "}" ]]; then
            post_end=1
            echo "${post}" | $1
            if (( $? )); then
                echo "${post}"
            fi
        fi
    done
}

# Exit if the unprefixed id format is in use in the current directory
function old_ids
{
    for filename in post-+([1-9][0-9])*(-+([a-zA-Z0-9_])).md
    do
        [[ -f "${filename}" ]] || continue
        echo "You appear to have a repository using the old unprefixed filename format.  Please run '$0 migrate'"
        exit 1
    done
}

# Pull the posts from a given Ello username into the current directory
#   pull [username]
function pull
{
    old_ids

    while getopts 'i' arg;
    do
        case "${arg}" in
            i)  infile=${OPTARG}
                ;;
        esac
    done
    shift $((OPTIND-1))

    if (( $# > 0 )); then
        username=$1
        source="https://ello.co/${username}.json"
        write_conf './.et' 'source' "${source}"
    elif ! [[ -v infile ]]; then
        source=$(get_conf './.et' 'source')
        if (( $? )); then
            exit ${FAIL};
        fi
    fi

    count=0
    for i in post-*.md
    do
        [[ -f "${i}" ]] && (( count++ ))
    done

    repo_type=$(has_repo)
    rc=$?
    if (( count ));  then
        if (( rc )); then
            confirm -e "This is a destructive activity and will overwrite all previously retrieved posts.  You do not appear to have a version control system active in this directory.  Are you sure you wish to do this?  (Type 'yes' to confirm)"
        elif has_uncommitted_changes "${repo_type}"; then
            confirm -e "This is a destructive activity and will overwrite all previously retrieved posts.  You appear to have uncommitted changed to posts in this directory (using version control system: ${repo_type}).  Are you sure you wish to do this?  (Type 'yes' to confirm)"
        fi
    fi

    # If an infile specified, use instead of curl
    if [[ -v infile ]]; then
        cat "${infile}"
    else
        curl "${source}" 
    fi | jq '.posts[] | {id: .id, created_at: .created_at, body: .body}' | \
        each_post write_post
}

# Get the appropriate rename command for the repo format in use
function get_rename_cmd
{
    typeset -a rename_cmd
    repo_type=$(has_repo)
    case "${repo_type}" in
        hg)
            rename_cmd=(hg rename)
            ;;
        git)
            rename_cmd=(git mv)
            ;;
        *)
            rename_cmd=(mv)
            ;;
    esac
    echo "${rename_cmd[@]}"
}

# If there exists files using an unpadded id, migrate these to the padded
# format
function migrate
{
    typeset -a rename_cmd
    rename_cmd=( $(get_rename_cmd) )
    
    filename_exp='post-([0-9]+)(-[a-zA-Z0-9_]+)*\.md'
    for src in post-+([0-9])*(-+([a-zA-Z0-9_])).md
    do
        if [[ ${src} =~ ${filename_exp} ]]; then
            id=${BASH_REMATCH[1]}
            tags=${src##post-+([0-9])}
            patt="post-%0${ID_DIGITS}d%s" 
            dest=$(printf "${patt}" "${id}" "${tags}")
            "${rename_cmd[@]}" "${src}" "${dest}"
        fi
    done
}

# Return success if the first argument is equal to one of the remaining arguments
#   in_array needle arg2 [arg3] ...
function in_array
{
    needle=$1
    shift
    while (( $# > 0 ));
    do
        [[ "${needle}" == "$1" ]] && return ${SUCCESS}
        shift
    done
    return ${FAIL}
}

# Using the first argument as a joining string, echo the remaining arguments
# concatenated with that joining string
#   join_array glue arg2 [arg3] ...
function join_array
{
    glue=$1
    shift
    while (( $# > 0 ));
    do
        echo -n "$1"
        shift
        (( $# > 0 )) && echo -n "${glue}"
    done
}

# Apply tags to a given file
#   tag filename tag1 [tag2] ...
function tag
{
    old_ids

    if (( $# < 2 )); then
        exit
    fi

    typeset -a rename_cmd
    rename_cmd=( $(get_rename_cmd) )

    filename=$1
    shift
    new_tags=("$@")

    typeset -a tags
    stem=${filename%.md}
    filename_exp='post-([0-9]+)(-[a-zA-Z0-9_]+)*\.md'
    if [[ ${filename} =~ ${filename_exp} ]]; then
        id=${BASH_REMATCH[1]}
        if [[ -n "${BASH_REMATCH[2]}" ]]; then
            tags_str=${stem#post-${id}-}
            if (( ${#tags_str} )); then
                IFS=- tags=(${tags_str})
            fi
        fi
        if (( ${#new_tags[@]} )); then
            for tag in "${new_tags[@]}"
            do
                echo ${tag}
                if [[ -v tags ]]; then
                    ind=${#tags[@]}
                else
                    ind=0
                fi
                if (( ind ))  && in_array "${tag}" "${tags[@]}"; then
                    continue
                fi
                tags[${ind}]=${tag}
            done
        fi
        new_filename=$(printf \
            post-%s-%s.md "${id}" "$(join_array '-' "${tags[@]}")")
        "${rename_cmd[@]}" "${filename}" "${new_filename}"
    fi
}

# Print usage
function usage
{
    echo "USAGE: $0 command [options ...]

Where command is one of:

    pull    retrieve the latest published articles from a given user:

                pull username
                    specify a username to retrieve posts from
                    subsequently, this username may be omitted

            This is intended to be used in conjunction with a version
            control tool such as git or mercurial to allow you to more
            easily track the changes you have made to your Ello posts
            and comments.

    tag     apply tag(s) to a given file:

                et tag filename tag1 tag2 ...

            Any tags already present in the filename will be ignored.

            If the current directory is in version control, the VCS
            will be used to rename  the file.  Else, the OS's mv
            command will be used."
}

# if file was run as executable (as opposed to sourced)
if [[ "$0" == "${BASH_SOURCE}" ]]; then

    set -u

    # Parse command line

    if (( $# < 1 )); then
        usage
        exit ${FAIL}
    fi

    command=$1
    shift
    case "${command}" in
        pull)
            pull "$@"
            ;;
        migrate)
            migrate "$@"
            ;;
        tag)
            tag "$@"
            ;;
        *)
            usage
            exit ${FAIL}
            ;;
    esac

fi
